<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カルテ番号照合アプリ - 高速・高精度版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/5.0.4/tesseract.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .camera-section {
            flex: 0 0 20%;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            background: white;
            border-bottom: 1px solid #e9ecef;
        }

        .status-section {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        .footer {
            background: white;
            padding: 0.5rem;
            text-align: center;
            border-top: 1px solid #e9ecef;
            font-size: 0.75rem;
            color: #6c757d;
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            max-width: 400px;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        #video {
            width: 100%;
            height: auto;
            display: block;
            object-fit: cover;
            aspect-ratio: 16/9;
        }

        .guide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .guide-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70%;
            height: 25px;
            border: 2px solid #28a745;
            border-radius: 4px;
            background: rgba(40, 167, 69, 0.1);
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.2);
            transition: all 0.3s ease;
        }

        .guide-frame.scanning {
            border-color: #17a2b8;
            background: rgba(23, 162, 184, 0.1);
            box-shadow: 0 0 15px rgba(23, 162, 184, 0.3);
        }

        .guide-frame.detected {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.3);
        }

        .guide-frame.matched {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.2);
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.4);
            animation: success-pulse 0.6s ease-in-out;
        }

        @keyframes success-pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .guide-frame::before {
            content: 'カルテ番号を枠内に';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.6rem;
            white-space: nowrap;
        }

        .controls {
            margin-top: 0.5rem;
            text-align: center;
        }

        .btn {
            background: white;
            color: #495057;
            border: 1px solid #dee2e6;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            margin: 0.2rem;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .btn:hover {
            background: #f8f9fa;
            border-color: #adb5bd;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .btn.primary:hover {
            background: #0056b3;
            border-color: #0056b3;
        }

        .status-panel {
            background: white;
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
            padding: 0.8rem;
            border-radius: 8px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        .status-value {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            font-weight: bold;
        }

        .detected {
            color: #28a745;
        }

        .pending {
            color: #6c757d;
        }

        .processing {
            color: #17a2b8;
            font-style: italic;
        }

        .matched {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .unmatched {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .mode-btn {
            background: white;
            color: #495057;
            border: 1px solid #dee2e6;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .mode-btn.active {
            background: #495057;
            color: white;
            border-color: #495057;
        }

        .mode-btn:hover:not(.active) {
            background: #f8f9fa;
            border-color: #adb5bd;
        }

        .single-scan-info {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            padding: 0.8rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            color: #0c5aa6;
        }

        .duplicate-result {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 0.8rem;
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        .duplicate-numbers {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            margin-top: 0.5rem;
        }

        .performance-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 0.6rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            font-size: 0.8rem;
            color: #856404;
        }

        .confidence-bar {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            margin: 0.3rem 0;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545, #ffc107, #28a745);
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .match-icon {
            font-size: 1.3rem;
            margin-left: 0.5rem;
        }

        .history {
            margin-top: 1rem;
            font-size: 0.85rem;
            color: #6c757d;
        }

        .history-item {
            padding: 0.3rem 0.5rem;
            margin: 0.2rem 0;
            background: #f1f3f4;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            border: 1px solid #e9ecef;
            color: #495057;
            font-size: 0.75rem;
            line-height: 1.3;
        }

        .history-item.success {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            text-align: center;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: #6c757d;
        }

        .spinner {
            border: 3px solid #f1f3f4;
            border-radius: 50%;
            border-top: 3px solid #6c757d;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-right: 0.8rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .settings-panel {
            background: #f8f9fa;
            padding: 0.8rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid #dee2e6;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-toggle {
            width: 40px;
            height: 20px;
            background: #dee2e6;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .setting-toggle.active {
            background: #28a745;
        }

        .setting-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
        }

        .setting-toggle.active::after {
            transform: translateX(20px);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="camera-section">
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <span>高速OCRエンジンを初期化中...</span>
            </div>

            <div id="error" class="error-message" style="display: none;"></div>

            <div id="videoContainer" class="video-wrapper" style="display: none;">
                <video id="video" autoplay playsinline></video>
                <div class="guide-overlay">
                    <div id="guideFrame" class="guide-frame"></div>
                </div>
            </div>

            <div class="controls">
                <button id="startScanBtn" class="btn primary">⚡ 高速スキャン開始</button>
                <button id="stopScanBtn" class="btn" style="display: none;">⏸️ スキャン停止</button>
                <button id="resetBtn" class="btn" style="display: none;">🔄 リセット</button>
                <button id="retryBtn" class="btn" style="display: none;">📷 再試行</button>
            </div>
        </div>

        <div class="status-section">
            <div class="mode-selector">
                <button id="singleModeBtn" class="mode-btn active">🔍 1回スキャン</button>
                <button id="sequentialModeBtn" class="mode-btn">📋 2回スキャン</button>
            </div>

            <div id="performanceInfo" class="performance-info" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>🚀 処理性能</span>
                    <span id="processingTime">---ms</span>
                </div>
                <div class="confidence-bar">
                    <div id="confidenceBar" class="confidence-fill" style="width: 0%;"></div>
                </div>
                <div style="font-size: 0.75rem; margin-top: 0.3rem;">
                    信頼度: <span id="confidenceText">0%</span> | 
                    認識速度: <span id="speedText">---</span>
                </div>
            </div>

            <div class="settings-panel">
                <div class="setting-item">
                    <span>🔧 高速モード</span>
                    <div id="fastModeToggle" class="setting-toggle active"></div>
                </div>
                <div class="setting-item">
                    <span>🎯 高精度モード</span>
                    <div id="precisionModeToggle" class="setting-toggle active"></div>
                </div>
                <div class="setting-item">
                    <span>📊 パフォーマンス表示</span>
                    <div id="performanceToggle" class="setting-toggle"></div>
                </div>
            </div>

            <div id="singleScanInfo" class="single-scan-info">
                💡 1枚の用紙に記載された2つの同じカルテ番号を自動検出します
            </div>

            <div id="statusPanel" class="status-panel" style="display: none;">
                <div id="sequentialStatus" style="display: none;">
                    <div class="status-item">
                        <span class="status-label">現在の検出番号:</span>
                        <span id="currentNumber" class="status-value pending">---</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">1回目 (領収書):</span>
                        <span id="firstNumber" class="status-value pending">未検出</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">2回目 (処方箋):</span>
                        <span id="secondNumber" class="status-value pending">未検出</span>
                    </div>
                </div>

                <div id="singleScanStatus">
                    <div class="status-item">
                        <span class="status-label">検出された番号:</span>
                        <span id="detectedNumbers" class="status-value pending">高速スキャン開始を押してください</span>
                    </div>
                </div>

                <div id="matchResult" class="status-item" style="display: none;">
                    <span class="status-label">照合結果:</span>
                    <span class="status-value">
                        <span id="matchStatus">確認中</span>
                        <span id="matchIcon" class="match-icon"></span>
                    </span>
                </div>

                <div id="duplicateResult" class="duplicate-result" style="display: none;">
                    <strong>✅ 同じ番号を検出しました</strong>
                    <div id="duplicateNumbers" class="duplicate-numbers"></div>
                </div>

                <div class="history">
                    <strong>検出履歴:</strong>
                    <div id="historyList"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        📋 カルテ番号照合アプリ - 高速・高精度版 v2.0
    </div>

    <canvas id="canvas" style="display: none;"></canvas>
    <canvas id="processingCanvas" style="display: none;"></canvas>

    <script>
        class HighPerformanceChartScanner {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.processingCanvas = document.getElementById('processingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.processingCtx = this.processingCanvas.getContext('2d');
                this.worker = null;
                this.workerPool = [];
                this.stream = null;
                this.isProcessing = false;
                
                this.detectionHistory = [];
                this.maxHistoryLength = 10;
                this.firstDetectedNumber = null;
                this.secondDetectedNumber = null;
                this.isMatched = false;
                
                this.scanMode = 'single';
                this.isScanning = false;
                
                // 性能追跡
                this.performanceStats = {
                    processingTimes: [],
                    lastProcessingTime: 0,
                    avgProcessingTime: 0,
                    successRate: 0,
                    totalScans: 0,
                    successfulScans: 0
                };
                
                // 高速化設定
                this.settings = {
                    fastMode: true,
                    precisionMode: true,
                    showPerformance: false,
                    confidenceThreshold: 0.8,
                    adaptiveInterval: true,
                    maxWorkers: 2
                };
                
                // 動的最適化
                this.optimizedROI = null;
                this.lastSuccessfulROI = null;
                this.scanInterval = 800; // 初期間隔
                this.minInterval = 400;
                this.maxInterval = 2000;
                
                // プリプロセッシングキャッシュ
                this.preprocessCache = new Map();
                this.maxCacheSize = 50;
                
                this.init();
            }

            async init() {
                try {
                    await this.initCamera();
                    await this.initWorkerPool();
                    this.setupEventListeners();
                    this.hideLoading();
                } catch (error) {
                    this.showError('初期化に失敗しました: ' + error.message);
                }
            }

            async initCamera() {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920, min: 1280 },
                        height: { ideal: 1080, min: 720 },
                        frameRate: { ideal: 30, min: 15 }
                    }
                };

                try {
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    await new Promise(resolve => this.video.onloadedmetadata = resolve);
                } catch (error) {
                    throw new Error('カメラアクセスに失敗しました。ブラウザでカメラの使用を許可してください。');
                }
            }

            async initWorkerPool() {
                const poolSize = this.settings.maxWorkers;
                
                for (let i = 0; i < poolSize; i++) {
                    const worker = await Tesseract.createWorker('jpn+eng', 1, {
                        logger: () => {} // ログを無効化して高速化
                    });

                    await worker.setParameters({
                        tessedit_char_whitelist: '0123456789',
                        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
                        tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                        preserve_interword_spaces: '0',
                        user_defined_dpi: '300'
                    });

                    this.workerPool.push({
                        worker: worker,
                        busy: false,
                        lastUsed: 0
                    });
                }
            }

            getAvailableWorker() {
                const available = this.workerPool.find(w => !w.busy);
                if (available) {
                    available.busy = true;
                    available.lastUsed = Date.now();
                    return available;
                }
                
                // 最も古く使用されたワーカーを選択
                const oldest = this.workerPool.reduce((prev, current) => 
                    (prev.lastUsed < current.lastUsed) ? prev : current
                );
                oldest.busy = true;
                oldest.lastUsed = Date.now();
                return oldest;
            }

            releaseWorker(workerInfo) {
                workerInfo.busy = false;
            }

            setupEventListeners() {
                // ボタンイベント
                setTimeout(() => {
                    this.setupButtonEvents();
                    this.setupSettingToggles();
                }, 100);
            }

            setupButtonEvents() {
                const buttons = {
                    resetBtn: () => this.reset(),
                    retryBtn: () => this.retry(),
                    startScanBtn: () => this.startScanning(),
                    stopScanBtn: () => this.stopScanning(),
                    sequentialModeBtn: () => this.switchMode('sequential'),
                    singleModeBtn: () => this.switchMode('single')
                };

                Object.entries(buttons).forEach(([id, handler]) => {
                    const element = document.getElementById(id);
                    if (element && !element.hasAttribute('data-listener-added')) {
                        element.addEventListener('click', (e) => {
                            e.preventDefault();
                            handler();
                        });
                        element.setAttribute('data-listener-added', 'true');
                    }
                });
            }

            setupSettingToggles() {
                const toggles = {
                    fastModeToggle: 'fastMode',
                    precisionModeToggle: 'precisionMode',
                    performanceToggle: 'showPerformance'
                };

                Object.entries(toggles).forEach(([id, setting]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('click', () => {
                            this.settings[setting] = !this.settings[setting];
                            element.classList.toggle('active', this.settings[setting]);
                            
                            if (setting === 'showPerformance') {
                                this.togglePerformanceDisplay();
                            }
                        });
                    }
                });
            }

            togglePerformanceDisplay() {
                const performanceInfo = document.getElementById('performanceInfo');
                if (performanceInfo) {
                    performanceInfo.style.display = this.settings.showPerformance ? 'block' : 'none';
                }
            }

            switchMode(mode) {
                console.log('Switching to mode:', mode);
                this.scanMode = mode;
                this.reset();
                
                const allModeButtons = document.querySelectorAll('.mode-btn');
                allModeButtons.forEach(btn => btn.classList.remove('active'));
                
                const sequentialStatus = document.getElementById('sequentialStatus');
                const singleScanStatus = document.getElementById('singleScanStatus');
                const singleScanInfo = document.getElementById('singleScanInfo');
                
                if (mode === 'sequential') {
                    document.getElementById('sequentialModeBtn')?.classList.add('active');
                    if (sequentialStatus) sequentialStatus.style.display = 'block';
                    if (singleScanStatus) singleScanStatus.style.display = 'none';
                    if (singleScanInfo) singleScanInfo.style.display = 'none';
                } else {
                    document.getElementById('singleModeBtn')?.classList.add('active');
                    if (sequentialStatus) sequentialStatus.style.display = 'none';
                    if (singleScanStatus) singleScanStatus.style.display = 'block';
                    if (singleScanInfo) singleScanInfo.style.display = 'block';
                }
            }

            hideLoading() {
                const loading = document.getElementById('loading');
                const videoContainer = document.getElementById('videoContainer');
                const statusPanel = document.getElementById('statusPanel');

                if (loading) loading.style.display = 'none';
                if (videoContainer) videoContainer.style.display = 'block';
                if (statusPanel) statusPanel.style.display = 'block';
                
                // ボタンを表示
                ['resetBtn', 'startScanBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.style.display = 'inline-block';
                });
            }

            showError(message) {
                const loading = document.getElementById('loading');
                const errorDiv = document.getElementById('error');
                const retryBtn = document.getElementById('retryBtn');

                if (loading) loading.style.display = 'none';
                if (errorDiv) {
                    errorDiv.textContent = message;
                    errorDiv.style.display = 'block';
                }
                if (retryBtn) retryBtn.style.display = 'inline-block';
            }

            async startScanning() {
                this.isScanning = true;
                this.updateGuideFrame('scanning');
                
                const startBtn = document.getElementById('startScanBtn');
                const stopBtn = document.getElementById('stopScanBtn');
                if (startBtn) startBtn.style.display = 'none';
                if (stopBtn) stopBtn.style.display = 'inline-block';
                
                this.scanLoop();
            }

            stopScanning() {
                this.isScanning = false;
                this.updateGuideFrame('default');
                
                const startBtn = document.getElementById('startScanBtn');
                const stopBtn = document.getElementById('stopScanBtn');
                if (startBtn) startBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
            }

            updateGuideFrame(state) {
                const frame = document.getElementById('guideFrame');
                if (!frame) return;
                
                frame.className = `guide-frame ${state}`;
            }

            async scanLoop() {
                if (!this.isScanning || this.isMatched) return;
                
                const startTime = performance.now();
                
                try {
                    await this.captureAndProcess();
                    
                    if (this.settings.adaptiveInterval) {
                        this.adaptScanInterval(true);
                    }
                } catch (error) {
                    console.error('Scan error:', error);
                    if (this.settings.adaptiveInterval) {
                        this.adaptScanInterval(false);
                    }
                }
                
                const processingTime = performance.now() - startTime;
                this.updatePerformanceStats(processingTime);
                
                setTimeout(() => this.scanLoop(), this.scanInterval);
            }

            adaptScanInterval(success) {
                if (success) {
                    // 成功時は間隔を短縮
                    this.scanInterval = Math.max(this.minInterval, this.scanInterval * 0.9);
                } else {
                    // 失敗時は間隔を延長
                    this.scanInterval = Math.min(this.maxInterval, this.scanInterval * 1.1);
                }
            }

            updatePerformanceStats(processingTime) {
                this.performanceStats.processingTimes.push(processingTime);
                if (this.performanceStats.processingTimes.length > 10) {
                    this.performanceStats.processingTimes.shift();
                }
                
                this.performanceStats.lastProcessingTime = processingTime;
                this.performanceStats.avgProcessingTime = 
                    this.performanceStats.processingTimes.reduce((a, b) => a + b, 0) / 
                    this.performanceStats.processingTimes.length;
                
                if (this.settings.showPerformance) {
                    this.updatePerformanceDisplay();
                }
            }

            updatePerformanceDisplay() {
                const timeElement = document.getElementById('processingTime');
                const speedElement = document.getElementById('speedText');
                
                if (timeElement) {
                    timeElement.textContent = `${this.performanceStats.lastProcessingTime.toFixed(0)}ms`;
                }
                
                if (speedElement) {
                    const fps = (1000 / this.performanceStats.avgProcessingTime).toFixed(1);
                    speedElement.textContent = `${fps} FPS`;
                }
            }

            updateConfidence(confidence) {
                if (!this.settings.showPerformance) return;
                
                const confidenceBar = document.getElementById('confidenceBar');
                const confidenceText = document.getElementById('confidenceText');
                
                if (confidenceBar) {
                    confidenceBar.style.width = `${confidence}%`;
                }
                
                if (confidenceText) {
                    confidenceText.textContent = `${confidence.toFixed(1)}%`;
                }
            }

            async captureAndProcess() {
                if (this.isProcessing || this.isMatched) return;

                this.isProcessing = true;

                try {
                    const imageData = this.captureOptimizedFrame();
                    if (!imageData) return;

                    if (this.scanMode === 'sequential') {
                        const result = await this.performEnhancedOCR(imageData);
                        if (result && result.text) {
                            this.handleSequentialDetection(result.text, result.confidence);
                        }
                    } else {
                        const duplicates = await this.performParallelDuplicateDetection(imageData);
                        if (duplicates.length > 0) {
                            this.handleDuplicateDetection(duplicates);
                        } else {
                            this.updateProgressiveStatus('🔍 高速スキャン中...', 'processing');
                        }
                    }
                } catch (error) {
                    console.error('処理エラー:', error);
                } finally {
                    this.isProcessing = false;
                }
            }

            captureOptimizedFrame() {
                if (!this.video || !this.canvas) return null;

                const videoWidth = this.video.videoWidth;
                const videoHeight = this.video.videoHeight;
                
                if (videoWidth === 0 || videoHeight === 0) return null;
                
                // ROIを最適化
                const roi = this.getAdaptiveROI(videoWidth, videoHeight);
                
                this.canvas.width = roi.width;
                this.canvas.height = roi.height;
                
                this.ctx.drawImage(
                    this.video, 
                    roi.x, roi.y, roi.width, roi.height,
                    0, 0, roi.width, roi.height
                );
                
                return this.ctx.getImageData(0, 0, roi.width, roi.height);
            }

            getAdaptiveROI(videoWidth, videoHeight) {
                // 前回成功したROIがあれば使用
                if (this.lastSuccessfulROI && this.settings.fastMode) {
                    const expandedROI = {
                        x: Math.max(0, this.lastSuccessfulROI.x - 20),
                        y: Math.max(0, this.lastSuccessfulROI.y - 10),
                        width: Math.min(videoWidth, this.lastSuccessfulROI.width + 40),
                        height: Math.min(videoHeight, this.lastSuccessfulROI.height + 20)
                    };
                    return expandedROI;
                }
                
                // デフォルトROI
                if (this.scanMode === 'single') {
                    return {
                        x: 0,
                        y: 0,
                        width: videoWidth,
                        height: videoHeight
                    };
                } else {
                    const frameWidth = videoWidth * 0.8;
                    const frameHeight = Math.min(videoHeight * 0.1, 80);
                    return {
                        x: (videoWidth - frameWidth) / 2,
                        y: (videoHeight - frameHeight) / 2,
                        width: frameWidth,
                        height: frameHeight
                    };
                }
            }

            async performEnhancedOCR(imageData) {
                const workerInfo = this.getAvailableWorker();
                
                try {
                    // 複数の前処理を並列実行
                    const processedImages = await this.createMultiplePreprocessedImages(imageData);
                    
                    // 最も有望な画像を選択
                    const bestImage = this.selectBestProcessedImage(processedImages);
                    
                    this.processingCanvas.width = bestImage.width;
                    this.processingCanvas.height = bestImage.height;
                    this.processingCtx.putImageData(bestImage, 0, 0);
                    
                    const startTime = performance.now();
                    const { data: { text, confidence } } = await workerInfo.worker.recognize(this.processingCanvas);
                    const processingTime = performance.now() - startTime;
                    
                    const numbers = text.replace(/[^0-9]/g, '');
                    
                    if (numbers.length >= 3) {
                        return {
                            text: numbers,
                            confidence: confidence,
                            processingTime: processingTime
                        };
                    }
                    
                    return null;
                } finally {
                    this.releaseWorker(workerInfo);
                }
            }

            async createMultiplePreprocessedImages(imageData) {
                const images = [];
                
                // 標準前処理
                images.push(this.preprocessStandard(imageData));
                
                if (this.settings.precisionMode) {
                    // 高コントラスト版
                    images.push(this.preprocessHighContrast(imageData));
                    
                    // ガウシアンブラー + シャープ化
                    images.push(this.preprocessBlurSharpen(imageData));
                    
                    // 適応的二値化
                    images.push(this.preprocessAdaptiveBinary(imageData));
                }
                
                return images;
            }

            preprocessStandard(imageData) {
                const data = new Uint8ClampedArray(imageData.data);
                
                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    const enhanced = Math.min(255, gray * 1.3);
                    const binary = enhanced > 140 ? 255 : 0;
                    
                    data[i] = data[i + 1] = data[i + 2] = binary;
                }
                
                return new ImageData(data, imageData.width, imageData.height);
            }

            preprocessHighContrast(imageData) {
                const data = new Uint8ClampedArray(imageData.data);
                
                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    const enhanced = Math.min(255, Math.max(0, (gray - 128) * 2 + 128));
                    const binary = enhanced > 160 ? 255 : 0;
                    
                    data[i] = data[i + 1] = data[i + 2] = binary;
                }
                
                return new ImageData(data, imageData.width, imageData.height);
            }

            preprocessBlurSharpen(imageData) {
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;
                
                // ガウシアンブラー適用
                const blurred = this.applyGaussianBlur(data, width, height);
                
                // シャープ化
                for (let i = 0; i < blurred.length; i += 4) {
                    const gray = Math.round(0.299 * blurred[i] + 0.587 * blurred[i + 1] + 0.114 * blurred[i + 2]);
                    const sharpened = Math.min(255, Math.max(0, gray * 1.5 - 64));
                    const binary = sharpened > 150 ? 255 : 0;
                    
                    blurred[i] = blurred[i + 1] = blurred[i + 2] = binary;
                }
                
                return new ImageData(blurred, width, height);
            }

            preprocessAdaptiveBinary(imageData) {
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;
                
                // 適応的二値化
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const gray = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
                        
                        // 局所的な平均を計算
                        const localMean = this.calculateLocalMean(data, x, y, width, height, 5);
                        const threshold = localMean * 0.9;
                        
                        const binary = gray > threshold ? 255 : 0;
                        data[idx] = data[idx + 1] = data[idx + 2] = binary;
                    }
                }
                
                return new ImageData(data, width, height);
            }

            applyGaussianBlur(data, width, height) {
                const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
                const kernelSum = 16;
                const result = new Uint8ClampedArray(data);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        let r = 0, g = 0, b = 0;
                        
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const kidx = ((y + ky) * width + (x + kx)) * 4;
                                const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                                r += data[kidx] * weight;
                                g += data[kidx + 1] * weight;
                                b += data[kidx + 2] * weight;
                            }
                        }
                        
                        result[idx] = r / kernelSum;
                        result[idx + 1] = g / kernelSum;
                        result[idx + 2] = b / kernelSum;
                    }
                }
                
                return result;
            }

            calculateLocalMean(data, x, y, width, height, kernelSize) {
                let sum = 0;
                let count = 0;
                const half = Math.floor(kernelSize / 2);
                
                for (let ky = -half; ky <= half; ky++) {
                    for (let kx = -half; kx <= half; kx++) {
                        const nx = x + kx;
                        const ny = y + ky;
                        
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const idx = (ny * width + nx) * 4;
                            const gray = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
                            sum += gray;
                            count++;
                        }
                    }
                }
                
                return count > 0 ? sum / count : 128;
            }

            selectBestProcessedImage(images) {
                // エッジ量と文字らしさを評価して最適な画像を選択
                let bestImage = images[0];
                let bestScore = 0;
                
                for (const image of images) {
                    const score = this.evaluateImageQuality(image);
                    if (score > bestScore) {
                        bestScore = score;
                        bestImage = image;
                    }
                }
                
                return bestImage;
            }

            evaluateImageQuality(imageData) {
                const data = imageData.data;
                let edgeCount = 0;
                let contrastSum = 0;
                const width = imageData.width;
                const height = imageData.height;
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        const current = data[idx];
                        
                        // エッジ検出
                        const rightIdx = (y * width + x + 1) * 4;
                        const bottomIdx = ((y + 1) * width + x) * 4;
                        
                        const edgeStrength = Math.abs(current - data[rightIdx]) + Math.abs(current - data[bottomIdx]);
                        if (edgeStrength > 100) {
                            edgeCount++;
                        }
                        
                        contrastSum += edgeStrength;
                    }
                }
                
                return edgeCount * 0.7 + (contrastSum / (width * height)) * 0.3;
            }

            async performParallelDuplicateDetection(imageData) {
                try {
                    this.updateProgressiveStatus('🔍 並列解析中...', 'processing');
                    
                    // 複数の前処理画像を作成
                    const processedImages = await this.createMultiplePreprocessedImages(imageData);
                    
                    // 並列でOCR実行
                    const ocrPromises = processedImages.map(async (image, index) => {
                        const workerInfo = this.getAvailableWorker();
                        try {
                            this.processingCanvas.width = image.width;
                            this.processingCanvas.height = image.height;
                            this.processingCtx.putImageData(image, 0, 0);
                            
                            const { data: { text, confidence } } = await workerInfo.worker.recognize(this.processingCanvas);
                            return { text, confidence, index };
                        } finally {
                            this.releaseWorker(workerInfo);
                        }
                    });
                    
                    const results = await Promise.all(ocrPromises);
                    
                    // 最高信頼度の結果を選択
                    const bestResult = results.reduce((best, current) => 
                        current.confidence > best.confidence ? current : best
                    );
                    
                    this.updateConfidence(bestResult.confidence);
                    
                    const allNumbers = this.extractAllNumbers(bestResult.text);
                    
                    if (allNumbers.length > 0) {
                        this.showCandidateNumbers(allNumbers);
                        this.addNumbersToHistory(allNumbers, bestResult.confidence);
                        
                        // 即座判定
                        const instantMatch = this.performInstantMatch(allNumbers);
                        if (instantMatch.matched) {
                            return [instantMatch.number];
                        }
                    }
                    
                    this.updateProgressiveStatus('✅ 照合分析中...', 'processing');
                    return this.findDuplicates(allNumbers, bestResult.text);
                    
                } catch (error) {
                    console.error('並列重複検出エラー:', error);
                    return [];
                }
            }

            performInstantMatch(detectedNumbers) {
                const numberCounts = {};
                
                detectedNumbers.forEach(number => {
                    if (number.length >= 4) {
                        numberCounts[number] = (numberCounts[number] || 0) + 1;
                    }
                });
                
                for (const [number, count] of Object.entries(numberCounts)) {
                    if (count >= 2) {
                        return { matched: true, number: number };
                    }
                }
                
                return { matched: false };
            }

            showCandidateNumbers(candidates) {
                const detectedElement = document.getElementById('detectedNumbers');
                if (detectedElement && candidates.length > 0) {
                    const validCandidates = candidates.filter(n => n.length >= 4);
                    if (validCandidates.length > 0) {
                        detectedElement.textContent = `検出: ${validCandidates.join(', ')}`;
                        detectedElement.className = 'status-value processing';
                        this.updateGuideFrame('detected');
                    }
                }
            }

            updateProgressiveStatus(message, className = 'processing') {
                const detectedElement = document.getElementById('detectedNumbers');
                if (detectedElement) {
                    detectedElement.textContent = message;
                    detectedElement.className = `status-value ${className}`;
                }
            }

            addNumbersToHistory(numbers, confidence = 0) {
                const timestamp = new Date().toLocaleTimeString();
                const confidenceText = confidence ? ` (信頼度: ${confidence.toFixed(1)}%)` : '';
                const historyEntry = `[${timestamp}] 検出: ${numbers.join(', ')}${confidenceText}`;
                
                this.detectionHistory.push(historyEntry);
                if (this.detectionHistory.length > this.maxHistoryLength) {
                    this.detectionHistory.shift();
                }
                
                this.updateHistory();
            }

            extractAllNumbers(text) {
                const numberPattern = /\d{3,12}/g;
                const matches = text.match(numberPattern) || [];
                const uniqueNumbers = [...new Set(matches)];
                
                if (uniqueNumbers.length > 0) {
                    console.log('検出された番号:', uniqueNumbers);
                }
                
                return uniqueNumbers;
            }

            findDuplicates(numbers, originalText) {
                const duplicates = [];
                
                for (const number of numbers) {
                    const regex = new RegExp(number, 'g');
                    const matches = (originalText.match(regex) || []).length;
                    
                    if (matches >= 2 && number.length >= 4) {
                        duplicates.push(number);
                    }
                }
                
                return duplicates;
            }

            handleSequentialDetection(number, confidence) {
                this.detectionHistory.push(`${number} (${confidence.toFixed(1)}%)`);
                if (this.detectionHistory.length > this.maxHistoryLength) {
                    this.detectionHistory.shift();
                }

                const currentElement = document.getElementById('currentNumber');
                if (currentElement) {
                    currentElement.textContent = number;
                    currentElement.className = 'status-value detected';
                }
                
                this.updateConfidence(confidence);
                this.updateHistory();

                const stableNumber = this.getStableNumber();
                
                if (stableNumber) {
                    if (!this.firstDetectedNumber) {
                        this.firstDetectedNumber = stableNumber;
                        const firstElement = document.getElementById('firstNumber');
                        if (firstElement) {
                            firstElement.textContent = stableNumber;
                            firstElement.className = 'status-value detected';
                        }
                        this.detectionHistory = [];
                    } else if (!this.secondDetectedNumber && stableNumber === this.firstDetectedNumber) {
                        this.secondDetectedNumber = stableNumber;
                        const secondElement = document.getElementById('secondNumber');
                        if (secondElement) {
                            secondElement.textContent = stableNumber;
                            secondElement.className = 'status-value detected';
                        }
                        this.showMatchResult(true);
                    } else if (!this.secondDetectedNumber && stableNumber !== this.firstDetectedNumber) {
                        this.secondDetectedNumber = stableNumber;
                        const secondElement = document.getElementById('secondNumber');
                        if (secondElement) {
                            secondElement.textContent = stableNumber;
                            secondElement.className = 'status-value detected';
                        }
                        this.showMatchResult(false);
                    }
                }
            }

            handleDuplicateDetection(duplicates) {
                this.isMatched = true;
                this.performanceStats.totalScans++;
                this.performanceStats.successfulScans++;
                
                this.updateProgressiveStatus('🎉 照合完了！', 'detected');
                this.updateGuideFrame('matched');
                
                const detectedElement = document.getElementById('detectedNumbers');
                if (detectedElement) {
                    detectedElement.textContent = duplicates.join(', ');
                    detectedElement.className = 'status-value detected';
                }
                
                const duplicateResult = document.getElementById('duplicateResult');
                const duplicateNumbers = document.getElementById('duplicateNumbers');
                
                if (duplicateResult) duplicateResult.style.display = 'block';
                if (duplicateNumbers) duplicateNumbers.textContent = `番号: ${duplicates[0]}`;
                
                // 成功した位置を記録
                this.recordSuccessfulROI();
                
                // 履歴に記録
                const timestamp = new Date().toLocaleTimeString();
                this.detectionHistory.push(`[${timestamp}] ✅ 照合完了: ${duplicates[0]}`);
                this.updateHistory();
                
                // スキャンを自動停止
                this.stopScanning();
            }

            recordSuccessfulROI() {
                if (this.optimizedROI) {
                    this.lastSuccessfulROI = { ...this.optimizedROI };
                }
            }

            getStableNumber() {
                if (this.detectionHistory.length < 2) return null;

                const numbers = this.detectionHistory.map(entry => entry.split(' ')[0]);
                const latest = numbers[numbers.length - 1];
                const secondLatest = numbers[numbers.length - 2];
                
                if (latest === secondLatest) {
                    return latest;
                }

                const counts = {};
                numbers.forEach(num => {
                    counts[num] = (counts[num] || 0) + 1;
                });

                const maxCount = Math.max(...Object.values(counts));
                if (maxCount >= Math.ceil(numbers.length / 2)) {
                    return Object.keys(counts).find(key => counts[key] === maxCount);
                }

                return null;
            }

            updateHistory() {
                const historyList = document.getElementById('historyList');
                if (historyList) {
                    if (this.detectionHistory.length === 0) {
                        historyList.innerHTML = '<div class="history-item">まだ検出履歴がありません</div>';
                    } else {
                        historyList.innerHTML = this.detectionHistory
                            .slice(-8)
                            .map(entry => {
                                const isSuccess = entry.includes('✅');
                                const className = isSuccess ? 'history-item success' : 'history-item';
                                return `<div class="${className}">${entry}</div>`;
                            })
                            .join('');
                    }
                }
            }

            showMatchResult(isMatch) {
                this.isMatched = true;
                this.updateGuideFrame('matched');
                
                const matchResult = document.getElementById('matchResult');
                const matchStatus = document.getElementById('matchStatus');
                const matchIcon = document.getElementById('matchIcon');

                if (matchResult) matchResult.style.display = 'flex';

                if (isMatch) {
                    if (matchResult) matchResult.classList.add('matched');
                    if (matchStatus) matchStatus.textContent = '照合完了';
                    if (matchIcon) matchIcon.textContent = '✅';
                } else {
                    if (matchResult) matchResult.classList.add('unmatched');
                    if (matchStatus) matchStatus.textContent = '番号不一致';
                    if (matchIcon) matchIcon.textContent = '❌';
                }
            }

            reset() {
                this.firstDetectedNumber = null;
                this.secondDetectedNumber = null;
                this.isMatched = false;
                this.detectionHistory = [];
                this.lastSuccessfulROI = null;
                this.scanInterval = 800;

                this.stopScanning();

                const matchResult = document.getElementById('matchResult');
                const duplicateResult = document.getElementById('duplicateResult');

                if (matchResult) {
                    matchResult.style.display = 'none';
                    matchResult.className = 'status-item';
                }
                if (duplicateResult) duplicateResult.style.display = 'none';

                this.updateHistory();

                if (this.scanMode === 'sequential') {
                    ['currentNumber', 'firstNumber', 'secondNumber'].forEach((id, index) => {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = index === 0 ? '---' : '未検出';
                            element.className = 'status-value pending';
                        }
                    });
                } else {
                    const detectedElement = document.getElementById('detectedNumbers');
                    if (detectedElement) {
                        detectedElement.textContent = '高速スキャン開始を押してください';
                        detectedElement.className = 'status-value pending';
                    }
                }
                
                this.updateConfidence(0);
                this.updateGuideFrame('default');
            }

            async retry() {
                const errorDiv = document.getElementById('error');
                const retryBtn = document.getElementById('retryBtn');
                const loading = document.getElementById('loading');

                if (errorDiv) errorDiv.style.display = 'none';
                if (retryBtn) retryBtn.style.display = 'none';
                if (loading) loading.style.display = 'flex';

                try {
                    await this.initCamera();
                    this.hideLoading();
                } catch (error) {
                    this.showError('再試行に失敗しました: ' + error.message);
                }
            }

            destroy() {
                this.workerPool.forEach(workerInfo => {
                    if (workerInfo.worker) {
                        workerInfo.worker.terminate();
                    }
                });
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
                
                this.preprocessCache.clear();
            }
        }

        let scanner;
        window.addEventListener('DOMContentLoaded', () => {
            scanner = new HighPerformanceChartScanner();
        });

        window.addEventListener('beforeunload', () => {
            if (scanner) {
                scanner.destroy();
            }
        });
    </script>
</body>
</html>
